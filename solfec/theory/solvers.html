
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Constraint solvers &#8212; PARMES  documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/parmes.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Bulk materials" href="bulkmat.html" />
    <link rel="prev" title="Contact formulations" href="conform.html" />
  
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  
  <link rel="alternate" type="application/atom+xml"  href="../../blog/atom.xml" title="PARMES/blog">
  
  
  <style type="text/css">
    ul.ablog-archive {list-style: none; overflow: auto; margin-left: 0px}
    ul.ablog-archive li {float: left; margin-right: 5px; font-size: 80%}
    ul.postlist a {font-style: italic;}
    ul.postlist-style-disc {list-style-type: disc;}
    ul.postlist-style-none {list-style-type: none;}
    ul.postlist-style-circle {list-style-type: circle;}
  </style>

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="constraint-solvers">
<span id="solfec-theory-solvers"></span><h1>Constraint solvers<a class="headerlink" href="#constraint-solvers" title="Permalink to this headline">¶</a></h1>
<p>Constraint solvers are used to find approximate a solution to the <a class="reference internal" href="constraints.html#solfec-theory-constraints"><span class="std std-ref">constraints</span></a> equations</p>
<div class="math notranslate nohighlight">
\[\mathbf{C}\left(\mathbf{U},\mathbf{R}\right)=\mathbf{0}\]</div>
<p>expressing <a class="reference internal" href="joints.html#solfec-theory-joints"><span class="std std-ref">joints</span></a> and <a class="reference internal" href="conform.html#solfec-theory-conform"><span class="std std-ref">contact conditions</span></a>, together with
the <a class="reference internal" href="locdyn.html#solfec-theory-locdyn"><span class="std std-ref">local dynamics</span></a> equations</p>
<div class="math notranslate nohighlight">
\[\mathbf{U}=\mathbf{B}+\mathbf{WR}\]</div>
<p>The merit function used as one of the termination conditions by all solvers, and the algorithms of the Solfec solvers themselves,
are described in sections below.</p>
<div class="section" id="merit-function">
<h2>Merit function<a class="headerlink" href="#merit-function" title="Permalink to this headline">¶</a></h2>
<p>As discussed on the <a class="reference internal" href="basics.html#solfec-theory-basics"><span class="std std-ref">basics page</span></a>, at every time step an implicit equation
<span class="math notranslate nohighlight">\(\mathbf{C}\left(\mathbf{R}\right)=\mathbf{0}\)</span> is solved. This solution is approximate. In order to express its accuracy
as a scalar value, we formulate <span class="math notranslate nohighlight">\(\mathbf{C}\left(\mathbf{R}\right)\)</span> in terms of velocity
(see <a class="reference internal" href="conform.html#solfec-theory-conform-nsveq"><span class="std std-ref">the non-smooth velocity equation formulation</span></a>) and use</p>
<div class="math notranslate nohighlight">
\[g\left(\mathbf{R}\right)=\sum_{\alpha}\left\langle \mathbf{W}_{\alpha\alpha}^{-1}\mathbf{C}_{\alpha}\left(\mathbf{R}\right),
\mathbf{C}_{\alpha}\left(\mathbf{R}\right)\right\rangle /\sum_{\alpha}\left\langle \mathbf{W}_{\alpha\alpha}^{-1}\mathbf{B}_{\alpha},
\mathbf{B}_{\alpha}\right\rangle\]</div>
<p>in order to approximately measure the relative amount of “energy”, due to an inexact satisfaction of constraints. The denominator corresponds
to the kinetic energy of the relative free motion, hence <span class="math notranslate nohighlight">\(g\left(\mathbf{R}\right)\)</span> is the ratio of the “spurious energy” over the nominal
amount of the “energy available at the constraints”. Since inverting <span class="math notranslate nohighlight">\(\mathbf{W}\)</span> would be unpractical or impossible due to its singularity,
we only use the diagonal blocks, which are always positive definite. To recapitulate, in short</p>
<div class="math notranslate nohighlight">
\[g\left(\mathbf{R}\right)\simeq\frac{\mbox{&quot;spurious energy due to inaccurate solution&quot;}}{\mbox{&quot;free energy available at the constraints&quot;}}\]</div>
<p>Such merit function is used as one of the stopping criterions for the solvers described below.</p>
</div>
<div class="section" id="gauss-seidel-solver">
<span id="solfec-theory-solvers-gs"></span><h2>Gauss–Seidel solver<a class="headerlink" href="#gauss-seidel-solver" title="Permalink to this headline">¶</a></h2>
<p>The equations of <a class="reference internal" href="locdyn.html#solfec-theory-locdyn"><span class="std std-ref">local dynamics</span></a> read</p>
<div class="math notranslate nohighlight">
\[\mathbf{U}_{\alpha}=\mathbf{B}_{\alpha}+\sum_{\beta}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{U}_{\alpha}\)</span> are relative velocities and <span class="math notranslate nohighlight">\(\mathbf{R}_{\alpha}\)</span> are reactions at constraint points. <span class="math notranslate nohighlight">\(\mathbf{U}_{\alpha}\)</span>,
<span class="math notranslate nohighlight">\(\mathbf{R}_{\alpha}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{B}_{\alpha}\)</span> are 3–vectors, while <span class="math notranslate nohighlight">\(\mathbf{W}_{\alpha\beta}\)</span> are <span class="math notranslate nohighlight">\(3\times3\)</span> matrix blocks. Each
constraint equation can be formulated as</p>
<div class="math notranslate nohighlight">
\[\mathbf{C}_{\alpha}\left(\mathbf{U}_{\alpha},\mathbf{R}_{\alpha}\right)=\mathbf{0}\]</div>
<p>or in other words</p>
<div class="math notranslate nohighlight" id="equation-nleq">
<span class="eqno">(82)<a class="headerlink" href="#equation-nleq" title="Permalink to this equation">¶</a></span>\[\mathbf{C}_{\alpha}\left(\mathbf{B}_{\alpha}+\sum_{\beta}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta},\mathbf{R}_{\alpha}\right)=\mathbf{0}\]</div>
<p>A series of 3–component non–linear equations <a class="reference internal" href="#equation-nleq">(82)</a> for all constrains can be approximately solved using the below serial Gauss–Seidel paradigm</p>
<p><strong>SERIAL_GS</strong> <span class="math notranslate nohighlight">\(\left(Constraints,\epsilon,\gamma\right)\)</span> <br />
1 <span class="math notranslate nohighlight">\(\,\,\)</span> do <br />
2 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> for each <span class="math notranslate nohighlight">\(\alpha in Constraints\)</span> do <br />
3 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> <span class="math notranslate nohighlight">\(\mathbf{S}_{\alpha}=\mathbf{R}_{\alpha}\)</span> <br />
4 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> find <span class="math notranslate nohighlight">\(\mathbf{R}_{\alpha}\)</span> such that <span class="math notranslate nohighlight">\(\mathbf{C}_{\alpha}\left(\mathbf{B}_{\alpha}+\sum_{\beta}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta},\mathbf{R}_{\alpha}\right)=\mathbf{0}\)</span> <br />
5 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\,\,\,\,\)</span> assuming <span class="math notranslate nohighlight">\(\mathbf{R}_{\beta}=\mbox{constant}\)</span> for <span class="math notranslate nohighlight">\(\beta\ne\alpha\)</span> <br />
6 <span class="math notranslate nohighlight">\(\,\,\)</span>  while <span class="math notranslate nohighlight">\(\left\Vert \mathbf{S}-\mathbf{R}\right\Vert /\left\Vert \mathbf{R}\right\Vert &gt;\epsilon\)</span> and <span class="math notranslate nohighlight">\(g\left(\mathbf{R}\right)&gt;\gamma\)</span> <br /></p>
<p>Algorithm <strong>SERIAL_GS</strong> is quite simple: diagonal block problems are solved until reaction change is small enough. The Gauss–Seidel paradigm corresponds to the fact,
that the most recent off–diagonal reactions are used when solving the diagonal problem. Of course, because of that, a perfectly parallel implementation is not possible.
After all, reactions are updated in a sequence. We can nevertheless relax the need for sequential processing. Perhaps the most scalable Gauss–Seidel approach to date was
devised by Adams <a class="footnote-reference" href="#id4" id="id1">[1]</a>. Although originally it was used as a multigrid smoother, the core idea can be as well applied in our context. Each processor owes a subset of
(internal) constraints <span class="math notranslate nohighlight">\(Q_{i}\)</span>, where <span class="math notranslate nohighlight">\(i=1,2,...,n\)</span> are the processors indices. Therefore the local velocity update can be rewritten as</p>
<div class="math notranslate nohighlight">
\[\mathbf{U}_{\alpha}=\mathbf{B}_{\alpha}+\sum_{\beta\in Q_{i}}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta}+\sum_{\beta\notin Q_{i}}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta}\]</div>
<p>Some of the <span class="math notranslate nohighlight">\(\mathbf{W}_{\alpha\beta}\)</span> blocks and reactions <span class="math notranslate nohighlight">\(\mathbf{R}_{\beta}\)</span> correspond to the (external) constraints stored on other processors (<span class="math notranslate nohighlight">\(\beta\notin Q_{i}\)</span>).
Let us denote the set of corresponding reaction indices by <span class="math notranslate nohighlight">\(P_{i}\)</span>. That is</p>
<div class="math notranslate nohighlight">
\[P_{i}=\left\{ \beta:\exists\mathbf{W}_{\alpha\beta}\ne\mathbf{0}\mbox{ and }\alpha\in Q_{i}\mbox{ and }\beta\notin Q_{i}\right\}\]</div>
<p>For each <span class="math notranslate nohighlight">\(\beta\in P_{i}\)</span> we know an index of processor <span class="math notranslate nohighlight">\(cpu\left(\beta\right)\)</span> storing the constraint with index <span class="math notranslate nohighlight">\(\beta\)</span>.
For processor <span class="math notranslate nohighlight">\(i\)</span> we can then define a set of adjacent processors as follows</p>
<div class="math notranslate nohighlight">
\[adj\left(i\right)=\left\{ cpu\left(\beta\right):\beta\in P_{i}\right\}\]</div>
<p>When updating reactions, a processor needs to communicate only with other adjacent processors. We are going to optimize a pattern of this communication by
coloring the processors. We shall then assign to each processor a color, such that no two adjacent processors have the same color. A simple coloring method
is summarized in Algorithm <strong>COLOR</strong> below</p>
<p><strong>COLOR</strong> <span class="math notranslate nohighlight">\(\left(\right)\)</span> <br />
1 <span class="math notranslate nohighlight">\(\,\,\)</span> for <span class="math notranslate nohighlight">\(i=1,...,n\)</span> do <span class="math notranslate nohighlight">\(color\left[i\right]=0\)</span> <br />
2 <span class="math notranslate nohighlight">\(\,\,\)</span> for <span class="math notranslate nohighlight">\(i=1,...,n\)</span> do <br />
3 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> do <br />
4 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\,\,\,\,\)</span> <span class="math notranslate nohighlight">\(color\left[i\right]=color\left[i\right]+1\)</span> <br />
5 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> while for any <span class="math notranslate nohighlight">\(j\in adj\left(i\right)\)</span> there holds <span class="math notranslate nohighlight">\(color\left[i\right]=color\left[j\right]\)</span> <br /></p>
<p>We try to assign as few colors as possible. We then split the index sets <span class="math notranslate nohighlight">\(Q_{i}\)</span> as follows</p>
<div class="math notranslate nohighlight">
\[Top_{i}=\left\{ \alpha:\forall\mathbf{W}_{\alpha\beta}:\beta\in P_{i}\wedge color\left[cpu\left(\beta\right)\right]&lt;color\left[i\right]\right\}\]</div>
<div class="math notranslate nohighlight">
\[Bottom_{i}=\left\{ \alpha:\forall\mathbf{W}_{\alpha\beta}:\beta\in P_{i}\wedge color\left[cpu\left(\beta\right)\right]&gt;color\left[i\right]\right\}\]</div>
<div class="math notranslate nohighlight">
\[Middle_{i}=\left\{ \alpha:\forall\mathbf{W}_{\alpha\beta}:\beta\in P_{i}\wedge\alpha\notin Top_{i}\cup Bottom_{i}\right\}\]</div>
<div class="math notranslate nohighlight">
\[Inner_{i}=Q_{i}\setminus\left\{ Top_{i}\cup Bottom_{i}\cup Middle_{i}\right\}\]</div>
<p>The top constraints require communication only with processors of lower colors. The bottom constraints require communication only with processors of higher colors.
The middle constraints require communication with either. The inner constraints require no communication. The inner reactions are further split in two sets</p>
<div class="math notranslate nohighlight">
\[Inner_{i}=Inner1_{i}\cup Inner2_{i}so that\]</div>
<div class="math notranslate nohighlight" id="equation-gsbalcnd">
<span class="eqno">(83)<a class="headerlink" href="#equation-gsbalcnd" title="Permalink to this equation">¶</a></span>\[\left|Bottom_{i}\right|+\left|Inner2_{i}\right|=\left|Top_{i}\right|+\left|Inner1_{i}\right|\]</div>
<p>The parallel Gauss–Seidel scheme is summarized in Algorithm <strong>PARALLEL_GS</strong> below. The presented version is simplified in the respect,
that alternate forward and backward runs are not accounted for (in terms of constraints ordering).</p>
<p><strong>SWEEP</strong> <span class="math notranslate nohighlight">\(\left(Set\right)\)</span> <br />
1 <span class="math notranslate nohighlight">\(\,\,\)</span> for each <span class="math notranslate nohighlight">\(\alpha\in Set\)</span> do <br />
2 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> find <span class="math notranslate nohighlight">\(\mathbf{R}_{\alpha}\)</span> such that <span class="math notranslate nohighlight">\(\mathbf{C}_{\alpha}\left(\mathbf{B}_{\alpha}+\sum_{\beta}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta},\mathbf{R}_{\alpha}\right)=\mathbf{0}\)</span> <br />
3 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\,\,\,\,\)</span> assuming <span class="math notranslate nohighlight">\(\mathbf{R}_{\beta}=\mbox{constant}\)</span> for <span class="math notranslate nohighlight">\(\beta\ne\alpha\)</span> <br /></p>
<p><strong>LOOP</strong> <span class="math notranslate nohighlight">\(\left(Set\right)\)</span> <br />
1 <span class="math notranslate nohighlight">\(\,\,\)</span> descending sort of <span class="math notranslate nohighlight">\(\alpha\in Set\)</span> based on <span class="math notranslate nohighlight">\(\max\left(color\left[cpu\left(\beta\right)\right]\right)\)</span> where <span class="math notranslate nohighlight">\(\exists\mathbf{W}_{\alpha\beta}\)</span> <br />
2 <span class="math notranslate nohighlight">\(\,\,\)</span> for each ordered <span class="math notranslate nohighlight">\(\alpha in Set\)</span> do <br />
3 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> for each <span class="math notranslate nohighlight">\(\beta\)</span> such that <span class="math notranslate nohighlight">\(\exists\mathbf{W}_{\alpha\beta}\)</span> and <span class="math notranslate nohighlight">\(color\left[cpu\left(\alpha\right)\right]&lt;color\left[cpu\left(\beta\right)\right]\)</span> do <br />
4 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\,\,\,\,\)</span> if not received <span class="math notranslate nohighlight">\(\left(\mathbf{R}_{\beta}\right)\)</span> then receive <span class="math notranslate nohighlight">\(\left(\mathbf{R}_{\beta}\right)\)</span> <br />
5 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> find <span class="math notranslate nohighlight">\(\mathbf{R}_{\alpha}\)</span> such that <span class="math notranslate nohighlight">\(\mathbf{C}_{\alpha}\left(\mathbf{B}_{\alpha}+\sum_{\beta}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta},\mathbf{R}_{\alpha}\right)=\mathbf{0}\)</span> <br />
6 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\,\,\,\,\)</span> assuming <span class="math notranslate nohighlight">\(\mathbf{R}_{\beta}=\mbox{constant}\)</span> for <span class="math notranslate nohighlight">\(\beta\ne\alpha\)</span> <br />
7 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> send <span class="math notranslate nohighlight">\(\left(\mathbf{R}_{\alpha}\right)\)</span> <br />
8 :math: <cite>,,</cite> receive all remaining <span class="math notranslate nohighlight">\(\mathbf{R}_{\beta}\)</span> <br /></p>
<p><strong>PARALLEL_GS</strong> <span class="math notranslate nohighlight">\(\left(\epsilon,\gamma\right)\)</span> <br />
1 <span class="math notranslate nohighlight">\(\,\,\)</span> COLOR <span class="math notranslate nohighlight">\(\left(\right)\)</span> <br />
2 <span class="math notranslate nohighlight">\(\,\,\)</span> do <br />
3 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> <span class="math notranslate nohighlight">\(\mathbf{S}=\mathbf{R}\)</span> <br />
4 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> SWEEP <span class="math notranslate nohighlight">\(\left(Top_{i}\right)\)</span> <br />
5 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> send <span class="math notranslate nohighlight">\(\left(Top_{i}\right)\)</span> <br />
6 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> SWEEP <span class="math notranslate nohighlight">\(\left(Inner2_{i}\right)\)</span> <br />
7 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> receive <span class="math notranslate nohighlight">\(\left(Top_{i}\right)\)</span> <br />
8 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> LOOP <span class="math notranslate nohighlight">\(\left(Middle_{i}\right)\)</span> <br />
9 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> SWEEP <span class="math notranslate nohighlight">\(\left(Bottom_{i}\right)\)</span> <br />
10 <span class="math notranslate nohighlight">\(\,\,\,\,\,\)</span> send <span class="math notranslate nohighlight">\(\left(Bottom_{i}\right)\)</span> <br />
11 <span class="math notranslate nohighlight">\(\,\,\,\,\,\)</span> SWEEP <span class="math notranslate nohighlight">\(\left(Inner1_{i}\right)\)</span> <br />
12 <span class="math notranslate nohighlight">\(\,\,\,\,\,\)</span> receive <span class="math notranslate nohighlight">\(\left(Bottom_{i}\right)\)</span> <br />
13 <span class="math notranslate nohighlight">\(\,\)</span> while <span class="math notranslate nohighlight">\(\left\Vert \mathbf{S}-\mathbf{R}\right\Vert /\left\Vert \mathbf{R}\right\Vert &gt;\epsilon\)</span> and <span class="math notranslate nohighlight">\(g\left(\mathbf{R}\right)&gt;\gamma\)</span></p>
<p>In <strong>PARALLEL_GS</strong> we first process the <span class="math notranslate nohighlight">\(Top_{i}\)</span> set: a single sweep over the corresponding diagonal block problems is performed in line 4. Then we send the
computed top reactions to the processors with lower colors. We try to overlap communication and computation, hence we sweep over the <span class="math notranslate nohighlight">\(Inner2_{i}\)</span> set (line 6) while
sending. We then receive the top reactions. It should be noted that all communication is asynchronous – we only wait to receive reactions immediately necessary
for computations. In line 8 we enter the loop processing the <span class="math notranslate nohighlight">\(Middle_{i}\)</span> set. This is the location of the computational bottleneck. Middle nodes communicate
with processors of higher and lower colors and hence, they need to be processed in a sequence. The sequential processing is still relaxed by using processor coloring.
In the <strong>LOOP</strong> algorithm we first sort the constraints according to the descending order of maximal colors of their adjacent processors (line 1). We then maintain
this ordering while processing constraints. As the top reactions were already sent, some of the constraints from the middle set will have their external reactions from
higher colors fully updated. These will be processed first in line 5 of LOOP and then sent to lower and higher (by color) processors in line 7. This way some processors
with lower colors will have their higher color off-diagonal reactions of middle set constraints fully updated and they will proceed next. And so on. At the end (line 8),
we need to receive all remaining reactions that have been sent in line 7 of <strong>LOOP</strong>. Coming back to <strong>PARALLEL_GS</strong>, after the bottleneck of the LOOP, in lines 9–12 we
process the <span class="math notranslate nohighlight">\(Bottom_{i}\)</span> and <span class="math notranslate nohighlight">\(Inner1_{i}\)</span> sets in the same way as we did with the <span class="math notranslate nohighlight">\(Top_{i}\)</span> and <span class="math notranslate nohighlight">\(Inner2_{i}\)</span> sets. The condition <a class="reference internal" href="#equation-gsbalcnd">(83)</a>
attempts to balance the amount of computations needed to hide the communication (e.g. the larger the <span class="math notranslate nohighlight">\(Top_{i}\)</span> set is, the larger the <span class="math notranslate nohighlight">\(Inner2_{i}\)</span> set becomes).
It should be noted that the convergence criterion in line 13 is global across all processors.</p>
<p>In <a class="reference internal" href="../user/solvers.html#solfec-user-solvers"><span class="std std-ref">User Manual Solvers Section</span></a> several variants of the parallel Gauss–Seidel algorithm are listed. Algorithm <strong>PARALLEL_GS</strong> corresponds to
the FULL variant. We might like to relax the bottleneck of <strong>LOOP</strong> in line 8 of <strong>PARALLEL_GS</strong> by replacing it with</p>
<p>8.1 <span class="math notranslate nohighlight">\(\,\,\)</span> SWEEP <span class="math notranslate nohighlight">\(\left(Middle_{i}\right)\)</span> <br />
8.2 <span class="math notranslate nohighlight">\(\,\,\)</span> send <span class="math notranslate nohighlight">\(\left(Middle_{i}\right)\)</span> <br />
8.3 <span class="math notranslate nohighlight">\(\,\,\)</span> receive <span class="math notranslate nohighlight">\(\left(Middle_{i}\right)\)</span> <br /></p>
<p>so that the middle nodes are processed in an inconsistent manner: the off–processor information corresponds to the previous iteration (just like in the Jacobi method).
Usually the <span class="math notranslate nohighlight">\(Middle_{i}\)</span> sets are small and hence this inconsistency does not have to lead to divergence (especially for deformable kinematics, where constraint
interactions are weak, while <span class="math notranslate nohighlight">\(\mathbf{W}\)</span> is diagonally dominant). This is the MIDDLE_JACOBI variant of the algorithm. The last variant corresponds to a rather
gross inconsistency: something usually called “a processor Gauss-Seidel method”. Let us define the set</p>
<div class="math notranslate nohighlight">
\[All_{i}=Top_{i}\cup Bottom_{i}\cup Middle_{i}\cup Inner_{i}\]</div>
<p>In this case, lines 4–12 of <strong>PARALLEL_GS</strong> need to be replaced with</p>
<p>3 <span class="math notranslate nohighlight">\(\,\,\)</span> SWEEP <span class="math notranslate nohighlight">\(\left(All_{i}\right)\)</span> <br />
4 <span class="math notranslate nohighlight">\(\,\,\)</span> send <span class="math notranslate nohighlight">\(\left(All_{i}\right)\)</span> <br />
5 <span class="math notranslate nohighlight">\(\,\,\)</span> receive <span class="math notranslate nohighlight">\(\left(All_{i}\right)\)</span> <br /></p>
<p>Although this kind of approach does work as a multigrid smoother, it has little use in our context. Nevertheless, we use it for illustration sake and name the BOUNDARY_JACOBI.</p>
</div>
<div class="section" id="projected-newton-solver">
<span id="solfec-theory-solvers-pqn"></span><h2>Projected Newton solver<a class="headerlink" href="#projected-newton-solver" title="Permalink to this headline">¶</a></h2>
<p>Using the <a class="reference internal" href="conform.html#solfec-theory-conform-nsveq"><span class="std std-ref">non–smooth velocity equation formulation</span></a> let us rewrite the frictional contact problem as</p>
<div class="math notranslate nohighlight">
\[\mathbf{C}\left(\mathbf{R}\right)=\mathbf{F}\left(\mathbf{R}\right)+\mathbf{m}\left(\mathbf{R}-\mathbf{F}\left(\mathbf{R}\right)\right)=\mathbf{0}\mbox{ and }\mathbf{R}\in K\]</div>
<p>where <span class="math notranslate nohighlight">\(K\)</span> is the direct sum of friction cones at all contact points. Since <span class="math notranslate nohighlight">\(\mathbf{C}\left(\mathbf{R}\right)\)</span> is not smooth, to compute <span class="math notranslate nohighlight">\(\nabla\mathbf{C}\)</span> we
generalize the approach from <a class="footnote-reference" href="#id5" id="id2">[2]</a> and <a class="footnote-reference" href="#id6" id="id3">[3]</a> and use a smoothed <span class="math notranslate nohighlight">\(\nabla_{\omega}\mathbf{C}\)</span> with <span class="math notranslate nohighlight">\(\omega&gt;0\)</span> (we skip the details here), where only the self–dual case
was considered (friction coefficient equal to 1). Our idea is to employ the following projected quasi–Newton step</p>
<div class="math notranslate nohighlight" id="equation-newton">
<span class="eqno">(84)<a class="headerlink" href="#equation-newton" title="Permalink to this equation">¶</a></span>\[\mathbf{R}^{k+1}=\mbox{proj}_{K}\left[\mathbf{R}^{k}-\mathbf{A}^{-1}\mathbf{C}\left(\mathbf{R}\right)\right]\]</div>
<p>so that, as required, the iterates remain within the friction cone and where</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}\simeq\nabla_{\omega}\mathbf{C}\]</div>
<p>is an easy to invert approximation of <span class="math notranslate nohighlight">\(\nabla_{\omega}\mathbf{C}\)</span>. Since in many practical situations <span class="math notranslate nohighlight">\(\nabla_{\omega}\mathbf{C}\)</span> is singular, we cannot do not employ
it directly. Instead, we then two variants of <span class="math notranslate nohighlight">\(\mathbf{A}\simeq\nabla_{\omega}\mathbf{C}\)</span>. The first one reads</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{1}=\nabla_{\omega}\mathbf{C}+\delta\mathbf{I},\mbox{ combined with GMRES.}\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta\ge0\)</span>. This is related to numerical integration of an artificial ODE</p>
<div class="math notranslate nohighlight">
\[\frac{d\mathbf{R}}{dt}=\mathbf{C}\left(\mathbf{R}\right)\]</div>
<p>to a steady state (take one step of implicit Euler, in the literature this is called pseudo–transient continuation). The second variant reads</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}_{2}=\mbox{diag}_{3\times3}\left[\nabla_{\omega}\mathbf{C}\right],\mbox{ combined with direct inversion.}\]</div>
<p>and it is combined with a heuristic stabilization technique</p>
<div class="math notranslate nohighlight">
\[\triangle\mathbf{R}^{k+1}=\left(1-\theta\right)\triangle\mathbf{R}^{k}-\theta\left(\mathbf{A}^{k}\right)^{-1}\mathbf{C}^{k}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\theta\in\left[0,1\right]\mbox{.}\]</div>
<p>We then have two variants of the projected quasi–Newton step:</p>
<ol class="arabic simple">
<li>PQN1:</li>
</ol>
<div class="math notranslate nohighlight">
\[\mathbf{R}^{k+1}=\mbox{proj}_{K}\left[\mathbf{R}^{k}-\left(\nabla_{\omega}\mathbf{C}^{k}+\delta\mathbf{I}\right)_{\mbox{GMRES}\left(\epsilon\left\Vert \mathbf{C}^{k}\right\Vert ,m\right)}^{-1}\mathbf{C}^{k}\right]\]</div>
<p>where GMRES is preconditioned with <span class="math notranslate nohighlight">\(\left[\mbox{diag}_{3\times3}\left(\nabla_{\omega}\mathbf{C}_{\alpha\alpha}^{k}+\delta\mathbf{I}\right)\right]^{-1}\)</span> and <span class="math notranslate nohighlight">\(\delta\)</span>,
<span class="math notranslate nohighlight">\(\epsilon\)</span> and <span class="math notranslate nohighlight">\(m\)</span> need to be suitably selected. The linear problem should be solved only roughly, usually <span class="math notranslate nohighlight">\(\epsilon=0.25\)</span> and <span class="math notranslate nohighlight">\(m=10\)</span> (iterations
bound) work well. For ill–conditioned problems a too accurate solution of the linear sub–problem results in a poor convergence rate. The diagonal regularization <span class="math notranslate nohighlight">\(\delta\)</span>
needs to be adjusted “by hand”. The automatic update formulas that can be found in literature work only for well–conditioned cases and hence they are not very useful for us.
For ill–conditioned problems one should pick <span class="math notranslate nohighlight">\(\delta\)</span> that delivers an overall best convergence behavior. Large values will slow down convergence, but stabilize it;
small values may destabilize convergence for ill–conditioned problems; <span class="math notranslate nohighlight">\(\delta\)</span> (typically <span class="math notranslate nohighlight">\(\ll1\)</span>) should be tuned together with <span class="math notranslate nohighlight">\(\epsilon\)</span> and <span class="math notranslate nohighlight">\(m\)</span>
(e.g. find a suitably small <span class="math notranslate nohighlight">\(\delta\)</span> first, then tweak <span class="math notranslate nohighlight">\(\epsilon\)</span>). Since rigorous analysis is still missing for these parameters, please experiment before settling
on specific values for a specific problem. Use linver = ‘GMRES’ in <a class="reference internal" href="../user/solvers.html#solfec-command-newton-solver"><span class="std std-ref">NEWTON_SOLVER</span></a> to enable this variant (this is also the default).</p>
<ol class="arabic simple" start="2">
<li>PQN2:</li>
</ol>
<div class="math notranslate nohighlight">
\[\mathbf{R}^{k+1}=\mbox{proj}_{K}\left[\mathbf{R}^{k}+\left(1-\theta\right)\triangle\mathbf{R}^{k}-\theta\left(\mbox{diag}_{3\times3}\left[\nabla_{\omega}\mathbf{C}^{k}\right]\right)^{-1}\mathbf{C}^{k}\right]\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta\in\left[0,1\right]\)</span> and the diagonal <span class="math notranslate nohighlight">\(3\times3\)</span> blocks of <span class="math notranslate nohighlight">\(\nabla_{\omega}\mathbf{C}^{k}\)</span> are directly inverted. This simple scheme is interesting
because it converges for a sufficiently small <span class="math notranslate nohighlight">\(\theta\)</span>, while it is essentially a nonlinear Jacobi–type method. Use linver = ‘DIAG’ in <a class="reference internal" href="../user/solvers.html#solfec-command-newton-solver"><span class="std std-ref">NEWTON_SOLVER</span></a>
to enable this variant.</p>
<p>Both variants are summarized as algorithms below.</p>
<p><strong>PQN1</strong> <span class="math notranslate nohighlight">\(\left(\mathbf{R},\gamma,n,\omega,\delta,m,\epsilon\right)\)</span> <br />
1 <span class="math notranslate nohighlight">\(\,\,\)</span> <span class="math notranslate nohighlight">\(\triangle\mathbf{R}^{0}=\mathbf{0}, k=0\)</span> <br />
2 <span class="math notranslate nohighlight">\(\,\,\)</span> Do <br />
3 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> <span class="math notranslate nohighlight">\(\mathbf{U}^{k}=\mathbf{W}\mathbf{R}^{k}+\mathbf{B}\)</span> <br />
4 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> Compute <span class="math notranslate nohighlight">\(\mathbf{C}^{k}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{A}^{k}=\nabla_{\omega}\mathbf{C}_{\alpha\alpha}^{k}+\delta\mathbf{I}\)</span> using smoothing <span class="math notranslate nohighlight">\(\omega\)</span> <br />
5 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> <span class="math notranslate nohighlight">\(\triangle\mathbf{R}^{k+1}=-\left(\mathbf{A}^{k}\right)_{\mbox{GMRES}\left(\epsilon\left\Vert \mathbf{C}^{k}\right\Vert ,m\right)}^{-1}\mathbf{C}^{k}\)</span> <br />
6 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> <span class="math notranslate nohighlight">\(\mathbf{R}^{k+1}=\mbox{proj}_{K}\left[\mathbf{R}^{k}+\triangle\mathbf{R}^{k+1}\right]\)</span> <br />
7 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> <span class="math notranslate nohighlight">\(k=k+1\)</span> <br />
8 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> while <span class="math notranslate nohighlight">\(g\left(\mathbf{R}^{k}\right)\ge\gamma\)</span> and <span class="math notranslate nohighlight">\(k&lt;n\)</span> <br /></p>
<p><strong>PQN2</strong> <span class="math notranslate nohighlight">\(\left(\mathbf{R},\theta,\gamma,n,\omega\right)\)</span> <br />
1 <span class="math notranslate nohighlight">\(\,\,\)</span> <span class="math notranslate nohighlight">\(\triangle\mathbf{R}^{0}=\mathbf{0}, k=0\)</span> <br />
2 <span class="math notranslate nohighlight">\(\,\,\)</span> Do <br />
3 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> <span class="math notranslate nohighlight">\(\mathbf{U}^{k}=\mathbf{W}\mathbf{R}^{k}+\mathbf{B}\)</span> <br />
4 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> Compute <span class="math notranslate nohighlight">\(\mathbf{C}^{k}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{A}^{k}=\mbox{diag}_{3\times3}\left[\nabla_{\omega}\mathbf{C}_{\alpha\alpha}^{k}\right]\)</span> using smoothing <span class="math notranslate nohighlight">\(\omega\)</span> <br />
5 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> <span class="math notranslate nohighlight">\(\triangle\mathbf{R}^{k+1}=\left(1-\theta\right)\triangle\mathbf{R}^{k}-\theta\left(\mathbf{A}^{k}\right)^{-1}\mathbf{C}^{k}\)</span> <br />
6 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> <span class="math notranslate nohighlight">\(\mathbf{R}^{k+1}=\mbox{proj}_{K}\left[\mathbf{R}^{k}+\triangle\mathbf{R}^{k+1}\right]\)</span> <br />
7 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> <span class="math notranslate nohighlight">\(k=k+1\)</span> <br />
8 <span class="math notranslate nohighlight">\(\,\,\)</span> while <span class="math notranslate nohighlight">\(g\left(\mathbf{R}^{k}\right)\ge\gamma\)</span> and <span class="math notranslate nohighlight">\(k&lt;n\)</span> <br /></p>
</div>
<div class="section" id="penalty-solver">
<span id="solfec-theory-solvers-penalty"></span><h2>Penalty Solver<a class="headerlink" href="#penalty-solver" title="Permalink to this headline">¶</a></h2>
<p>The penalty solver is quite straightforward. On each processor we split the constraints into <span class="math notranslate nohighlight">\(Contacts_{i}\)</span> and <span class="math notranslate nohighlight">\(Others_{i}\)</span>,
hence we separate contact constraints from bilateral ones. We then update the contacts using the spring–dashpot model and calculate reactions
of bilateral constraints using the Gauss–Seidel solver (fixed accuracy <span class="math notranslate nohighlight">\(\mbox{epsilon=1E-4, maxiter = 1000}\)</span> is used). We use the
Gauss–Seidel approach for non–contacts because in this case it is quite fast, while it avoids issues related to penalization of bilateral constraints.</p>
<p><strong>PENALTY_SOLVER</strong> <span class="math notranslate nohighlight">\(\left(\right)\)</span> <br />
1 <span class="math notranslate nohighlight">\(\,\,\)</span> for all <span class="math notranslate nohighlight">\(\alpha\)</span> in <span class="math notranslate nohighlight">\(Contacts_{i}\)</span> do <br />
2 <span class="math notranslate nohighlight">\(\,\,\,\,\,\,\)</span> SPRING_DASHPOT_CONTACT <span class="math notranslate nohighlight">\(\left(h,gap_{\alpha},spring_{\alpha},dashpot_{\alpha},friction_{\alpha},cohesion_{\alpha},cohesive_{\alpha}\right)\)</span> <br />
3 <span class="math notranslate nohighlight">\(\,\,\)</span> send <span class="math notranslate nohighlight">\(\left(Contacts_{i}\right)\)</span> <br />
4 <span class="math notranslate nohighlight">\(\,\,\)</span> receive <span class="math notranslate nohighlight">\(\left(Contacts_{i}\right)\)</span> <br />
5 <span class="math notranslate nohighlight">\(\,\,\)</span> PARALLEL_GS <span class="math notranslate nohighlight">\(\left(Others_{i}\right)\)</span> <br /></p>
<p>Algorithm <strong>PENALTY_SOLVER</strong> summarizes the method. First all contact forces are calculated using the <a class="reference internal" href="conform.html#spring-dashpot-contact"><span class="std std-ref">SPRING_DASHPOT_CONTACT algorithm</span></a>.
In lines 3 and 4 contact domain boundary contact forces are sent to and received on the neighboring processors. Finally, the parallel Gauss–Seidel algorithm is executed
to calculate the reactions of the bilateral constraints. In the serial mode lines 3 and 4 are skipped, while <strong>SERIAL_GS</strong> is used instead of the parallel one.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>The Gauss–Seidel solver is implemented in <a class="reference external" href="https://github.com/tkoziara/solfec/blob/master/bgs.c">bgs.c</a> and
<a class="reference external" href="https://github.com/tkoziara/solfec/blob/master/bgs.h">bgs.h</a>.
The projected Newton solver is implemented in <a class="reference external" href="https://github.com/tkoziara/solfec/blob/master/nts.c">nts.c</a> and
<a class="reference external" href="https://github.com/tkoziara/solfec/blob/master/nts.h">nts.h</a>.
The penalty solver is implemented in <a class="reference external" href="https://github.com/tkoziara/solfec/blob/master/pes.c">pes.c</a> and
<a class="reference external" href="https://github.com/tkoziara/solfec/blob/master/pes.h">pes.h</a>.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Mark F. Adams, A distributed memory unstructured Gauss–Seidel algorithm for multigrid smoothers, In Supercomputing 01:
Proceedings of the 2001 ACM/IEEE conference on Supercomputing, pages 4-4, New York, USA, 2001.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Masao Fukushima, Zhi-Quan Luo, and Paul Tseng, Smoothing functions for second-order-cone complementarity problems,
SIAM Journal on Optimization, 12(2):436–460, 2002.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Shunsuke Hayashi, Nobuo Yamashita, and Masao Fukushima, A Combined Smoothing and Regularization Method for Monotone
Second–Order Cone Complementarity Problems, SIAM J. Optim., 15(2), 593–615, 2005.</td></tr>
</tbody>
</table>
</div>
</div>

  <div class="section">
  
  
  </div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">PARMES</a></h1>



<p class="blurb">Parallel mechanics and particulate media software blog</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=parmes&repo=parmes&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">SOLFEC</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../running.html">Running</a></li>
<li class="toctree-l2"><a class="reference internal" href="../user.html">User Manual</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../theory.html">Theory Manual</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="basics.html">Basics</a></li>
<li class="toctree-l3"><a class="reference internal" href="kinematics.html">Kinematics</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics.html">Dynamics</a></li>
<li class="toctree-l3"><a class="reference internal" href="timeint.html">Time integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="constraints.html">Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="locdyn.html">Local dynamics</a></li>
<li class="toctree-l3"><a class="reference internal" href="joints.html">Joints</a></li>
<li class="toctree-l3"><a class="reference internal" href="conpnt.html">Contact points</a></li>
<li class="toctree-l3"><a class="reference internal" href="conform.html">Contact formulations</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Constraint solvers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#merit-function">Merit function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gauss-seidel-solver">Gauss–Seidel solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#projected-newton-solver">Projected Newton solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#penalty-solver">Penalty Solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="bulkmat.html">Bulk materials</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../validation.html">Validation Manual</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xdmf.html">XDMF export</a></li>
<li class="toctree-l2"><a class="reference internal" href="../applications.html">Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l2"><a class="reference external" href="https://groups.google.com/forum/#!forum/solfec">Google group</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../dynlb/index.html">DYNLB</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parmec/index.html">PARMEC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vbox/index.html">VBOX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tgz/index.html">TGZ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trs/index.html">TRs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../blog/about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contact.html">Contact</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">SOLFEC</a><ul>
  <li><a href="../theory.html">Solfec Theory Manual</a><ul>
      <li>Previous: <a href="conform.html" title="previous chapter">Contact formulations</a></li>
      <li>Next: <a href="bulkmat.html" title="next chapter">Bulk materials</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../blog.html">Recent Posts</a></h3>
  <ul>
    
    
      <li><a href="../../blog/parmec_ball_joint.html">31 July - Parmec ball joint and articulated pendulum example</a></li>
    
      <li><a href="../../blog/parmec_spherical_joint.html">13 June - Parmec spherical joint</a></li>
    
      <li><a href="../../blog/parmec_spring_contact.html">23 May - Parmec spring contact</a></li>
    
      <li><a href="../../blog/spring_curve_tests.html">07 March - Parmec spring curve tests</a></li>
    
      <li><a href="../../blog/unspring_and_spring_state.html">15 January - UNSPRING and spring state in Parmec</a></li>
    
  </ul>

  <h3><a href="../../blog/tag.html">Tags</a></h3>
  <style type="text/css">
    ul.ablog-cloud {list-style: none; overflow: auto;}
    ul.ablog-cloud li {float: left; height: 20pt; line-height: 18pt; margin-right: 5px;}
    ul.ablog-cloud a {text-decoration: none; vertical-align: middle;}
    li.ablog-cloud-1{font-size: 80%;}
    li.ablog-cloud-2{font-size: 95%;}
    li.ablog-cloud-3{font-size: 110%;}
    li.ablog-cloud-4{font-size: 125%;}
    li.ablog-cloud-5{font-size: 140%;}
  </style>
  <ul class="ablog-cloud">
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/algebraic.html">algebraic</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/contact.html">contact</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/failure.html">failure</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/friction.html">friction</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/joints.html">joints</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/optimization.html">optimization</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-5">
        <a href="../../blog/tag/parmec.html">parmec</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/parmes.html">parmes</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/pendulum.html">pendulum</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/performance.html">performance</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/reports.html">reports</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-2">
        <a href="../../blog/tag/solfec.html">solfec</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/springs.html">springs</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-2">
        <a href="../../blog/tag/tests.html">tests</a></li>
      
    
      
      <li class="ablog-cloud ablog-cloud-1">
        <a href="../../blog/tag/torsion.html">torsion</a></li>
      
    
  </ul>

  <h3><a href="../../blog/archive.html">Archives</a></h3>
  <ul>
  
    
    <li><a href="../../blog/2018.html">2018 (5)</a></li>
    
  
    
    <li><a href="../../blog/2017.html">2017 (4)</a></li>
    
  
    
    <li><a href="../../blog/2016.html">2016 (1)</a></li>
    
  
  </ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018 PARMES team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.9</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
      |
      <a href="../../_sources/solfec/theory/solvers.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>